unit threading.dispatcher;

////////////////////////////////////////////////////////////////////////////////
//
//  ImageResize (c) 2019 Jan Schirrmacher, www.atomek.de
//
//  See https://github.com/Atomek61/ImageResize.git for licensing
//
//  threading.dispatcher.pas is the core mechanism of thread pooling, created
//  for ImageResize, but its independend.
//
////////////////////////////////////////////////////////////////////////////////

{$mode DELPHI}{$H+}

interface

uses
  Classes, SysUtils, generics.collections, generics.queue, SyncObjs;

resourcestring
  SCptOk = 'Ok';
  SCptCancelled = 'Cancelled';

type

  TDispatcher = class;
  TContext = class;
  TWorker = class;

  // Flags for printing and workers exit messages
  TLevel = (mlHint, mlInfo, mlWarning, mlCancelled, mlFatal);

  TPrintEvent = procedure(Sender :TObject; WorkerId: integer; const Line :string; Level :TLevel) of object;
  TProgressEvent = procedure(Sender :TObject; Progress :single) of object;

  // Derive a class from this and override the Execute-Method
  // The customers Execute-Method
  // - can frequently check Context.Cancelled to Exit(false)
  // - can Print a text, which will be threadsave queued to the outer thread
  // - should output Progress steps, the sum of the steps must be equal to
  //   the GetTaskSteps-result.
  // - must return true after successfully finishing
  // - can raise Exceptions - their message will be shown. If the Dispatcher
  //   has StopOnError=true, all workers will be stopped cooperative.
  TCustomTask = class abstract
  private
    FWorker :TWorker;
  protected
    function Execute(Context :TContext) :boolean; virtual; abstract;
    property Worker :TWorker read FWorker;
    function GetTaskSteps :integer; virtual; // Progress system: tells dispatcher how many steps this task goes
    procedure Print(const Text :string; Level :TLevel = mlInfo);
    procedure Progress(Steps :integer);
  public
    property TaskSteps :integer read GetTaskSteps;
  end;

  // A list of Tasks must be managed from outside and passed to the Execute-
  // Method of the Dispatcher.
  // At runtime, add TCustomTask-Derivates to this list.
  TTasks = class(TObjectList<TCustomTask>)
  public
    function GetTotalSteps :integer;
  end;

  // A Worker is a thread of the pool. The Dispatcher assigns a sequence of
  // tasks to it. Initially suspended, it is startet by the dispatcher.
  // A worker instance works on a sequence of tasks. The loop is
  // controlled in Execute.
  TWorker = class(TThread)
  private
    FContext :TContext;
    FTask :TCustomTask;
    FId :integer;
    procedure Start(Task :TCustomTask);
  protected
    procedure Execute; override; // Task and Suspend in a loop
  public
    constructor Create(Context :TContext; Id :integer);
    property Context :TContext read FContext;
    property Task :TCustomTask read FTask;
    property Id :integer read FId;
  end;

  // Base of all messages from workers to the dispatcher. Is the asynchronous
  // link between Worker and Dispatcher.
  TMessage = class
    Task :TCustomTask;
    constructor Create(Task :TCustomTask);
  end;

  // Print-messages are created by the task with help of a context
  TPrintMessage = class(TMessage)
    Text :string;
    Level :TLevel;
    constructor Create(Sender :TCustomTask; const Value :string; Level :TLevel = mlInfo);
  end;

  // Progress-messages are created by the task with help of a context
  // A complete task has n steps which must be published to the Dispatcher
  // with the tasks GetTaskSteps-method. This is required for a consistent
  // progress concept.
  TProgressMessage = class(TMessage)
    Steps :integer;
    constructor Create(Sender :TCustomTask; Steps :integer);
  end;

  // Mandatory message of a finished task, automatically generated by the
  // Workers Execute-Method
  TExitMessage = class(TPrintMessage);

  // A dynamically growing queue for thread-save messages from the workers to
  // the dispatcher
  TMessages = class(TQueue<TMessage>)
  private
    FQueueSection :TCriticalSection;
  public
    constructor Create;
    destructor Destroy; override;
    function GetCount :integer; override;
    procedure Push(Item :TMessage); override;
    function Pop(out Item :TMessage) :boolean; override;
  end;

  // A queue of available workers, used be the Dispatcher
  TWorkers = class(TQueue<TWorker>)
  protected
    function Drop :boolean; override;
  public
  end;

  // This is a helper object passed in the Execute-Method of the customers
  // Task-Class. It can be used to check if the user requests cancelling.
  TContext = class
  private
    FDispatcher :TDispatcher;
    FMessages :TMessages;
    function GetCancelled: boolean;
  public
    constructor Create(Dispatcher :TDispatcher);
    destructor Destroy; override;
    property Cancelled :boolean read GetCancelled; // To be checked frequently
    property Messages :TMessages read FMessages;
  end;

  // Main pool handler. Its Execute-Method is called from a processor with
  // a prepared tasklist. The Dispatcher assigns tasks to available workers,
  // handles the workers messages and watches abortion.
  TDispatcher = class
  public type
    TStats = record
      TaskCount :integer;
      Successful :integer;
      Failed :integer;
      Elapsed :integer; //ms
    end;
  private
    FCancel :boolean;
    FMaxWorkerCount :integer;
    FStopOnError :boolean;
    FStepCount :integer;
    FTotalSteps :integer;
    FStats :TStats;
    FOnPrint :TPrintEvent;
    FOnProgress :TProgressEvent;
    procedure Print(Sender :TCustomTask; const Text :string; Level :TLevel);
    procedure Progress(Sender :TCustomTask; Steps :integer);
  public
    constructor Create;
    destructor Destroy; override;
    function Execute(Tasks :TTasks) :boolean;
    procedure Cancel;
    property MaxWorkerCount :integer read FMaxWorkerCount write FMaxWorkerCount;
    property StopOnError :boolean read FStopOnError write FStopOnError;
    property OnPrint :TPrintEvent read FOnPrint write FOnPrint;
    property OnProgress :TProgressEvent read FOnProgress write FOnProgress;
    property Stats :TStats read FStats;
  end;

implementation

{ TCustomTask }

function TCustomTask.GetTaskSteps: integer;
begin
  result := 1;
end;

procedure TCustomTask.Print(const Text: string; Level: TLevel);
begin
  self.Worker.Context.Messages.Push(
    TPrintMessage.Create(self, Text, Level)
  );
end;

procedure TCustomTask.Progress(Steps: integer);
begin
  self.Worker.Context.Messages.Push(
    TProgressMessage.Create(self, Steps)
  );
end;

{ TTasks }

function TTasks.GetTotalSteps: integer;
var
  i :integer;
begin
  result := 0;
  for i:=0 to Count-1 do
    result += Items[i].GetTaskSteps;
end;

{ TProgressMessage }

constructor TProgressMessage.Create(Sender: TCustomTask; Steps :integer);
begin
  self.Steps := Steps;
  inherited Create(Sender);
end;

{ TPrintMessage }

constructor TPrintMessage.Create(Sender: TCustomTask; const Value: string; Level: TLevel);
begin
  self.Text := Value;
  self.Level := Level;
  inherited Create(Sender);
end;

{ TMessage }

constructor TMessage.Create(Task :TCustomTask);
begin
  inherited Create;
  self.Task := Task;
end;

{ TMessages }

constructor TMessages.Create;
begin
  inherited Create;
  FQueueSection := TCriticalSection.Create;
end;

destructor TMessages.Destroy;
begin
  inherited Destroy;
  FQueueSection.Free;
end;

function TMessages.GetCount: integer;
begin
  FQueueSection.Enter;
  result := inherited GetCount;
  FQueueSection.Leave;
end;

procedure TMessages.Push(Item: TMessage);
begin
  FQueueSection.Enter;
  try
    inherited Push(Item);
  finally
    FQueueSection.Leave;
  end;
end;

function TMessages.Pop(out Item: TMessage): boolean;
begin
  FQueueSection.Enter;
  try
    Result:=inherited Pop(Item);
  finally
    FQueueSection.Leave;
  end;
end;

{ TWorker }

constructor TWorker.Create(Context :TContext; Id :integer);
begin
  inherited Create(true);
  FContext := Context;
  FId := Id;
end;

procedure TWorker.Start(Task: TCustomTask);
begin
  FTask := Task;
  FTask.FWorker := self;
  Suspended := false;
end;

procedure TWorker.Execute;
var
  ExitMessage :TMessage;
begin
  while not Terminated do begin
    try
      if FTask.Execute(FContext) then
        ExitMessage := TExitMessage.Create(FTask, SCptOk, mlInfo)
      else
        ExitMessage := TExitMessage.Create(FTask, SCptCancelled, mlCancelled);
    except on E :Exception do
      ExitMessage := TExitMessage.Create(FTask, E.Message, mlFatal);
    end;
    FContext.FMessages.Push(ExitMessage);
    Suspended := true;
  end;
end;

{ TWorkers }

function TWorkers.Drop: boolean;
var
  First :TWorker;
begin
  if Peek(First) then
     First.Free;
  result := inherited Drop;
end;

{ TContext }

function TContext.GetCancelled: boolean;
begin
  result := FDispatcher.FCancel;
end;

constructor TContext.Create(Dispatcher: TDispatcher);
begin
  FDispatcher := Dispatcher;
  FMessages := TMessages.Create;
end;

destructor TContext.Destroy;
begin
  FMessages.Free;
  inherited Destroy;
end;

{ TDispatcher }

procedure TDispatcher.Print(Sender: TCustomTask; const Text: string;
  Level: TLevel);
begin
  if Assigned(FOnPrint) then
    FOnPrint(Sender, Sender.Worker.Id, Text, Level);
end;

procedure TDispatcher.Progress(Sender: TCustomTask; Steps :integer);
begin
  inc(FStepCount, Steps);
  if Assigned(FOnProgress) then
    FOnProgress(self, FStepCount/FTotalSteps);
end;

constructor TDispatcher.Create;
begin
  FStopOnError := true;
  FMaxWorkerCount := 0;
end;

destructor TDispatcher.Destroy;
begin
  inherited Destroy;
end;

// Core of the system - dispatches tasks to the workers and handles the messages.
function TDispatcher.Execute(Tasks: TTasks): boolean;
var
  Pool :TWorkers;             // Queue of ready workers
  PoolCapacity :integer;      // Maximum Number of workers
  Working :array of TWorker;  // List of currently working workers, Index is Id
  WorkingCount :integer;      // Number of valid entries in Working = Pool.Capacity - Pool.Count
  Worker :TWorker;            // A current worker
  Context :TContext;
  Msg :TMessage;
  Id :integer;
  NextTask :integer;
  t0 :Int64;
begin
  FStats.TaskCount := Tasks.Count;
  FStats.Successful := 0;
  FStats.Failed := 0;
  FStats.Elapsed := 0;
  Working := nil;

  // Is there anything to do?
  Pool := nil;
  Context := nil;
  try
    // Time measurement from now
    t0 := TThread.GetTickCount64;

    if Tasks.Count=0 then
      Exit(true);

    // Create a Context as an asynchronuos link between tasks and Dispatcher
    Context := TContext.Create(self);
    Context.FDispatcher := self;

    // Prepare progress system
    FTotalSteps := Tasks.GetTotalSteps;
    FStepCount := 0;

    // Calculate number of needed workers
    case MaxWorkerCount of
    0: // default
      PoolCapacity := TThread.ProcessorCount;
    else
      begin
        PoolCapacity := MaxWorkerCount;
        if PoolCapacity>TThread.ProcessorCount then
          PoolCapacity := TThread.ProcessorCount;
      end;
    end;
    if PoolCapacity>Tasks.Count then
      PoolCapacity := Tasks.Count;

    // Hire some workers
    Pool := TWorkers.Create(PoolCapacity);
    for Id := 0 to PoolCapacity-1 do
      Pool.Push(TWorker.Create(Context, Id));

    // Initiate the list of working workers Ids
    SetLength(Working, PoolCapacity);
    WorkingCount := 0;

    ////////////////////////////////////////////////////////////////////////////
    // Assign Tasks to Workers and handle their messages
    NextTask := 0;
    while true do begin

      // If StopOnError and all Workers have stopped then Exit
      if FCancel and StopOnError and (WorkingCount=0) then
        Exit(false);

      // If a task is available then assign it to a free worker
      if not FCancel and (NextTask<Tasks.Count) and Pool.Pop(Worker) then begin
        Working[Worker.Id] := Worker;
        inc(WorkingCount);
        Worker.Start(Tasks[NextTask]);
        inc(NextTask);
      end;

      // Handle worker messages
      if Context.FMessages.Empty then
        Sleep(0);
      while Context.FMessages.Pop(Msg) do begin
        try
          if Msg is TPrintMessage then with TPrintMessage(Msg) do begin
            self.Print(Task, Text, Level);
            if Msg is TExitMessage then with TExitMessage(Msg) do begin

              // Waiting for the tasks worker to become suspended
              while not Task.Worker.Suspended do Sleep(0);

              // Adding newly available worker to the pool
              Pool.Push(Task.Worker);

              // Remove him from the list of working
              Working[Task.Worker.Id] := nil;
              dec(WorkingCount);

              // Update stats
              if Level = mlInfo then
                inc(FStats.Successful)
              else
                inc(FStats.Failed);

              // If all workers finished their work and aborted then finish
              if (WorkingCount=0) and FCancel then
                Exit(false);

              // If all Tasks are done and no worker is currently running then finish
              if (NextTask=Tasks.Count) and (WorkingCount=0) then
                Exit(FStats.Failed = 0);

              // When error occured and not already aborting and StopOnError then stop all workers
              if (Level in [mlCancelled, mlFatal]) and not FCancel and StopOnError then
                // Terminate running workers and continue waiting for their ExitMessage
                Cancel;
            end;
          end else if Msg is TProgressMessage then with TProgressMessage(Msg) do begin
            self.Progress(Task, Steps);
          end;
        finally
          Msg.Free;
        end;
      end;
    end;
    result := true;
  finally
    Context.Free;
    // Fire all workers
    if Assigned(Pool) then begin
      while Pool.Pop(Worker) do
        Worker.Free;
      Pool.Free;
    end;
    FStats.Elapsed := TThread.GetTickCount64-t0;
  end;
end;

procedure TDispatcher.Cancel;
begin
  FCancel := true;
end;

end.

